version: 0.2

phases:
  install:
    commands:
      - echo "=== INSTALL PHASE ==="
      - echo "Verifying Buildah installation..."
      - buildah --version
      - echo "Configuring Buildah storage..."
      - mkdir -p /etc/containers
      - |
        cat > /etc/containers/storage.conf <<EOF
        [storage]
        driver = "vfs"
        runroot = "/var/run/containers/storage"
        graphroot = "/var/lib/containers/storage"
        EOF
      - mkdir -p /var/lib/containers/storage
      - mkdir -p /var/run/containers/storage
      - chmod 755 /var/lib/containers/storage
      - chmod 755 /var/run/containers/storage
      - echo "Buildah storage configured"

  pre_build:
    commands:
      - echo "=== PRE-BUILD PHASE ==="
      - echo "Logging in to Amazon ECR..."
      - |
        AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
        export AWS_ACCOUNT_ID
        ECR_REGISTRY="${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_DEFAULT_REGION}.amazonaws.com"
        export ECR_REGISTRY
        echo "ECR Registry: ${ECR_REGISTRY}"
      - |
        aws ecr get-login-password --region "${AWS_DEFAULT_REGION}" | buildah login --username AWS --password-stdin "${ECR_REGISTRY}"
      - echo "ECR login successful"
      - |
        REPOSITORY_URI="${ECR_REGISTRY}/image-services"
        BASE_IMAGE_URI="${ECR_REGISTRY}/image-base:base-image-node22"
        export REPOSITORY_URI
        export BASE_IMAGE_URI
        echo "Repository URI: ${REPOSITORY_URI}"
        echo "Base Image URI: ${BASE_IMAGE_URI}"
      - |
        echo "Pulling base Node.js image for ARM64..."
        buildah pull --platform linux/arm64 "${BASE_IMAGE_URI}" || {
          echo "ERROR: Failed to pull base image ${BASE_IMAGE_URI} for ARM64"
          exit 1
        }
        echo "Base image pulled successfully"
      - |
        if [ -n "${CODEBUILD_RESOLVED_SOURCE_VERSION}" ]; then
          COMMIT_HASH=$(echo "${CODEBUILD_RESOLVED_SOURCE_VERSION}" | cut -c 1-7)
        else
          COMMIT_HASH="latest"
        fi
        IMAGE_TAG="${COMMIT_HASH}"
        export IMAGE_TAG
        echo "Image tag: ${IMAGE_TAG}"

  build:
    commands:
      - echo "=== BUILD PHASE ==="
      - |
        AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
        export AWS_ACCOUNT_ID
        ECR_REGISTRY="${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_DEFAULT_REGION}.amazonaws.com"
        export ECR_REGISTRY
        REPOSITORY_URI="${ECR_REGISTRY}/image-services"
        BASE_IMAGE_URI="${ECR_REGISTRY}/image-base:base-image-node22"
        export REPOSITORY_URI
        export BASE_IMAGE_URI
        
        if [ -n "${CODEBUILD_RESOLVED_SOURCE_VERSION}" ]; then
          COMMIT_HASH=$(echo "${CODEBUILD_RESOLVED_SOURCE_VERSION}" | cut -c 1-7)
        else
          COMMIT_HASH="latest"
        fi
        IMAGE_TAG="${COMMIT_HASH}"
        export IMAGE_TAG
        
        echo "Building container image for ARM64..."
        echo "Base image: ${BASE_IMAGE_URI}"
        echo "Repository: ${REPOSITORY_URI}"
        echo "Tags: server, latest, ${IMAGE_TAG}"
      - |
        echo "Building image with buildah for ARM64..."
        buildah bud --platform linux/arm64 \
          --build-arg BASE_IMAGE="${BASE_IMAGE_URI}" \
          -t "${REPOSITORY_URI}:server" \
          -f ./code/Dockerfile ./code
      - |
        echo "Creating additional tags..."
        buildah tag "${REPOSITORY_URI}:server" "${REPOSITORY_URI}:latest"
        buildah tag "${REPOSITORY_URI}:server" "${REPOSITORY_URI}:${IMAGE_TAG}"
      - |
        echo "Built images:"
        buildah images | grep "${REPOSITORY_URI}" || echo "No images found"

  post_build:
    commands:
      - echo "=== POST-BUILD PHASE ==="
      - |
        AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
        export AWS_ACCOUNT_ID
        ECR_REGISTRY="${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_DEFAULT_REGION}.amazonaws.com"
        export ECR_REGISTRY
        REPOSITORY_URI="${ECR_REGISTRY}/image-services"
        export REPOSITORY_URI
        
        if [ -n "${CODEBUILD_RESOLVED_SOURCE_VERSION}" ]; then
          COMMIT_HASH=$(echo "${CODEBUILD_RESOLVED_SOURCE_VERSION}" | cut -c 1-7)
        else
          COMMIT_HASH="latest"
        fi
        IMAGE_TAG="${COMMIT_HASH}"
        export IMAGE_TAG
        
        echo "Pushing images to ECR..."
      - |
        echo "Pushing server tag..."
        buildah push "${REPOSITORY_URI}:server"
      - |
        echo "Pushing latest tag..."
        buildah push "${REPOSITORY_URI}:latest"
      - |
        echo "Pushing commit hash tag: ${IMAGE_TAG}"
        buildah push "${REPOSITORY_URI}:${IMAGE_TAG}"
      - echo "=== DEPLOYMENT PHASE ==="
      - |
        AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
        export AWS_ACCOUNT_ID
        ECR_REGISTRY="${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_DEFAULT_REGION}.amazonaws.com"
        export ECR_REGISTRY
        REPOSITORY_URI="${ECR_REGISTRY}/image-services"
        export REPOSITORY_URI
        
        echo "Looking for existing EC2 instance named 'server'..."
        INSTANCE_ID=$(aws ec2 describe-instances \
          --filters "Name=tag:Name,Values=server" "Name=instance-state-name,Values=running,stopped,stopping" \
          --region "${AWS_DEFAULT_REGION}" \
          --query 'Reservations[0].Instances[0].InstanceId' \
          --output text 2>/dev/null || echo "")
        
        if [ -n "${INSTANCE_ID}" ] && [ "${INSTANCE_ID}" != "None" ] && [ "${INSTANCE_ID}" != "null" ] && [ "${INSTANCE_ID}" != "none" ]; then
          echo "Found existing instance: ${INSTANCE_ID}"
          
          # Wait for instance to be running
          INSTANCE_STATE=$(aws ec2 describe-instances --instance-ids "${INSTANCE_ID}" --region "${AWS_DEFAULT_REGION}" --query 'Reservations[0].Instances[0].State.Name' --output text)
          if [ "${INSTANCE_STATE}" = "stopped" ]; then
            echo "Starting stopped instance..."
            aws ec2 start-instances --instance-ids "${INSTANCE_ID}" --region "${AWS_DEFAULT_REGION}"
            aws ec2 wait instance-running --instance-ids "${INSTANCE_ID}" --region "${AWS_DEFAULT_REGION}"
            sleep 30
          fi
          
          # Wait for SSM
          echo "Waiting for SSM to be ready..."
          for i in $(seq 1 30); do
            SSM_STATUS=$(aws ssm describe-instance-information --filters "Key=InstanceIds,Values=${INSTANCE_ID}" --region "${AWS_DEFAULT_REGION}" --query 'InstanceInformationList[0].PingStatus' --output text 2>/dev/null || echo "Offline")
            if [ "${SSM_STATUS}" = "Online" ]; then
              echo "SSM is ready"
              break
            fi
            echo "Waiting for SSM... ($i/30)"
            sleep 5
          done
          
          # Install container runtime
          echo "Preparing instance for containers..."
          PREPARE_ID=$(aws ssm send-command \
            --instance-ids "${INSTANCE_ID}" \
            --document-name "AWS-RunShellScript" \
            --parameters 'commands=["dnf install -y podman docker || yum install -y podman docker", "systemctl enable docker || systemctl enable podman", "systemctl start docker || systemctl start podman", "usermod -a -G docker ec2-user || usermod -a -G podman ec2-user"]' \
            --region "${AWS_DEFAULT_REGION}" \
            --query 'Command.CommandId' --output text)
          sleep 10
          aws ssm wait command-executed --command-id "${PREPARE_ID}" --instance-id "${INSTANCE_ID}" --region "${AWS_DEFAULT_REGION}" || true
          
          # Login to ECR
          echo "Logging into ECR on instance..."
          ECR_LOGIN_CMD="AWS_ACCOUNT_ID=\$(aws sts get-caller-identity --query Account --output text); aws ecr get-login-password --region ${AWS_DEFAULT_REGION} | docker login --username AWS --password-stdin \${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_DEFAULT_REGION}.amazonaws.com || aws ecr get-login-password --region ${AWS_DEFAULT_REGION} | podman login --username AWS --password-stdin \${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_DEFAULT_REGION}.amazonaws.com"
          ECR_LOGIN_ID=$(aws ssm send-command \
            --instance-ids "${INSTANCE_ID}" \
            --document-name "AWS-RunShellScript" \
            --parameters "commands=[\"${ECR_LOGIN_CMD}\"]" \
            --region "${AWS_DEFAULT_REGION}" \
            --query 'Command.CommandId' --output text)
          sleep 5
          aws ssm wait command-executed --command-id "${ECR_LOGIN_ID}" --instance-id "${INSTANCE_ID}" --region "${AWS_DEFAULT_REGION}" || true
          
          # Stop and remove old container
          echo "Stopping old container..."
          STOP_ID=$(aws ssm send-command \
            --instance-ids "${INSTANCE_ID}" \
            --document-name "AWS-RunShellScript" \
            --parameters 'commands=["docker stop service-app || podman stop service-app || true", "docker rm service-app || podman rm service-app || true"]' \
            --region "${AWS_DEFAULT_REGION}" \
            --query 'Command.CommandId' --output text)
          sleep 5
          aws ssm wait command-executed --command-id "${STOP_ID}" --instance-id "${INSTANCE_ID}" --region "${AWS_DEFAULT_REGION}" || true
          
          # Pull latest image
          echo "Pulling latest server image..."
          PULL_CMDS="docker system prune -af --volumes || podman system prune -af || true,docker pull ${REPOSITORY_URI}:server || podman pull ${REPOSITORY_URI}:server"
          PULL_ID=$(aws ssm send-command \
            --instance-ids "${INSTANCE_ID}" \
            --document-name "AWS-RunShellScript" \
            --parameters "commands=[\"${PULL_CMDS}\"]" \
            --region "${AWS_DEFAULT_REGION}" \
            --query 'Command.CommandId' --output text)
          sleep 20
          aws ssm wait command-executed --command-id "${PULL_ID}" --instance-id "${INSTANCE_ID}" --region "${AWS_DEFAULT_REGION}" || true
          
          # Start new container
          echo "Starting new container..."
          START_CMD="docker run -d -p 80:8080 -p 8080:8080 --name service-app --restart unless-stopped ${REPOSITORY_URI}:server || podman run -d -p 80:8080 -p 8080:8080 --name service-app --restart unless-stopped ${REPOSITORY_URI}:server"
          START_ID=$(aws ssm send-command \
            --instance-ids "${INSTANCE_ID}" \
            --document-name "AWS-RunShellScript" \
            --parameters "commands=[\"${START_CMD}\"]" \
            --region "${AWS_DEFAULT_REGION}" \
            --query 'Command.CommandId' --output text)
          sleep 5
          aws ssm wait command-executed --command-id "${START_ID}" --instance-id "${INSTANCE_ID}" --region "${AWS_DEFAULT_REGION}" || true
          
          # Verify container
          echo "Verifying container..."
          VERIFY_ID=$(aws ssm send-command \
            --instance-ids "${INSTANCE_ID}" \
            --document-name "AWS-RunShellScript" \
            --parameters 'commands=["docker ps | grep service-app || podman ps | grep service-app", "docker logs --tail 10 service-app || podman logs --tail 10 service-app"]' \
            --region "${AWS_DEFAULT_REGION}" \
            --query 'Command.CommandId' --output text)
          sleep 5
          VERIFY_OUTPUT=$(aws ssm get-command-invocation --command-id "${VERIFY_ID}" --instance-id "${INSTANCE_ID}" --region "${AWS_DEFAULT_REGION}" --query 'StandardOutputContent' --output text 2>/dev/null || echo "")
          echo "Container status: ${VERIFY_OUTPUT}"
          
          PUBLIC_IP=$(aws ec2 describe-instances --instance-ids "${INSTANCE_ID}" --region "${AWS_DEFAULT_REGION}" --query 'Reservations[0].Instances[0].PublicIpAddress' --output text)
          echo "Deployment completed!"
          echo "Instance: ${INSTANCE_ID}"
          echo "Public IP: ${PUBLIC_IP}"
          echo "Application: http://${PUBLIC_IP}:80 and http://${PUBLIC_IP}:8080"
        else
          echo "No existing instance found. Instance should be created by Terraform."
        fi

