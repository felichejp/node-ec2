version: 0.2

phases:
  install:
    commands:
      - echo "=== INSTALL PHASE ==="
      - echo "Environment: Amazon Linux 2023 (Custom Image)"
      - echo "Verifying tools..."
      - buildah --version
      - aws --version
      - |
        if [ -f /usr/bin/qemu-aarch64-static ]; then
          echo "QEMU static binary found"
        else
          echo "Warning: QEMU static binary not found (multi-arch build might fail)"
        fi
      
      - echo "Configuring Buildah storage..."
      - mkdir -p /etc/containers
      - |
        cat > /etc/containers/storage.conf <<'STORAGE_EOF'
        [storage]
        driver = "vfs"
        runroot = "/var/run/containers/storage"
        graphroot = "/var/lib/containers/storage"
        STORAGE_EOF
      - mkdir -p /var/lib/containers/storage
      - mkdir -p /var/run/containers/storage
      - chmod 755 /var/lib/containers/storage
      - chmod 755 /var/run/containers/storage
      - echo "Buildah storage configured"

  pre_build:
    commands:
      - echo "=== PRE-BUILD PHASE ==="
      - echo "Verifying CodeBuild environment (codebuild-buildah)..."
      - buildah --version
      - echo "CodeBuild environment verified"
      - echo "Logging in to Amazon ECR..."
      - |
        set -e
        AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
        export AWS_ACCOUNT_ID
        ECR_REGISTRY="${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_DEFAULT_REGION}.amazonaws.com"
        export ECR_REGISTRY
        echo "ECR Registry: ${ECR_REGISTRY}"
      - |
        set -e
        aws ecr get-login-password --region "${AWS_DEFAULT_REGION}" | buildah login --username AWS --password-stdin "${ECR_REGISTRY}"
      - echo "ECR login successful"
      - |
        set -e
        REPOSITORY_URI="${ECR_REGISTRY}/image-services"
        BASE_IMAGE_URI="${ECR_REGISTRY}/image-base:base-image-node22"
        CODEBUILD_IMAGE_URI="${ECR_REGISTRY}/image-base:codebuild-buildah"
        export REPOSITORY_URI
        export BASE_IMAGE_URI
        export CODEBUILD_IMAGE_URI
        echo "Repository URI: ${REPOSITORY_URI}"
        echo "Base Image URI (for application): ${BASE_IMAGE_URI}"
        echo "CodeBuild Image URI (environment): ${CODEBUILD_IMAGE_URI}"
      - |
        set -e
        echo "Verifying CodeBuild image exists in ECR..."
        if ! aws ecr describe-images --repository-name image-base --image-ids imageTag=codebuild-buildah --region "${AWS_DEFAULT_REGION}" --query 'imageDetails[0].imageTags' --output text 2>/dev/null; then
          echo "WARNING: Could not verify codebuild-buildah image in ECR"
        fi
      - |
        set -e
        echo "Pulling base Node.js image (base-image-node22) for ARM64..."
        if ! buildah pull --platform linux/arm64 "${BASE_IMAGE_URI}"; then
          echo "ERROR: Failed to pull base image ${BASE_IMAGE_URI} for ARM64"
          echo "Attempting to pull with latest tag..."
          LATEST_BASE_URI="${ECR_REGISTRY}/image-base:latest"
          if ! buildah pull --platform linux/arm64 "${LATEST_BASE_URI}"; then
            echo "ERROR: Failed to pull base image with latest tag"
            exit 1
          fi
          echo "Using latest tag for base image"
          BASE_IMAGE_URI="${LATEST_BASE_URI}"
          export BASE_IMAGE_URI
        fi
        echo "Base image (base-image-node22) pulled successfully for ARM64"
      - |
        set -e
        if [ -n "${CODEBUILD_RESOLVED_SOURCE_VERSION}" ]; then
          COMMIT_HASH=$(echo "${CODEBUILD_RESOLVED_SOURCE_VERSION}" | cut -c 1-7)
        else
          COMMIT_HASH="latest"
        fi
        IMAGE_TAG="${COMMIT_HASH}"
        export IMAGE_TAG
        echo "Image tag: ${IMAGE_TAG}"

  build:
    commands:
      - echo "=== BUILD PHASE ==="
      - echo "Building application image using"
      - echo "1. CodeBuild environment codebuild-buildah from ECR image-base"
      - echo "2. Base image base-image-node22 from ECR image-base"
      - echo "3. Application code from CodePipeline source zip"
      - echo "4. Target repository image-services ECR"
      - |
        set -e
        AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
        export AWS_ACCOUNT_ID
        ECR_REGISTRY="${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_DEFAULT_REGION}.amazonaws.com"
        export ECR_REGISTRY
        REPOSITORY_URI="${ECR_REGISTRY}/image-services"
        BASE_IMAGE_URI="${ECR_REGISTRY}/image-base:base-image-node22"
        export REPOSITORY_URI
        export BASE_IMAGE_URI
        
        if [ -n "${CODEBUILD_RESOLVED_SOURCE_VERSION}" ]; then
          COMMIT_HASH=$(echo "${CODEBUILD_RESOLVED_SOURCE_VERSION}" | cut -c 1-7)
        else
          COMMIT_HASH="latest"
        fi
        IMAGE_TAG="${COMMIT_HASH}"
        export IMAGE_TAG
        
        echo "Building container image for ARM64..."
        echo "Base image: ${BASE_IMAGE_URI}"
        echo "Repository: ${REPOSITORY_URI}"
        echo "Tags: server, latest, ${IMAGE_TAG}"
        echo "Application code location: ./code"
      - |
        set -e
        echo "Building image with buildah for ARM64..."
        echo "Using base-image-node22 and application code from ./code"
        buildah bud --platform linux/arm64 \
          --build-arg BASE_IMAGE="${BASE_IMAGE_URI}" \
          -t "${REPOSITORY_URI}:server" \
          -f ./code/Dockerfile ./code
      - |
        set -e
        echo "Creating additional tags..."
        buildah tag "${REPOSITORY_URI}:server" "${REPOSITORY_URI}:latest"
        buildah tag "${REPOSITORY_URI}:server" "${REPOSITORY_URI}:${IMAGE_TAG}"
      - |
        set -e
        echo "Built images:"
        if ! buildah images | grep -q "${REPOSITORY_URI}"; then
          echo "No images found"
        else
          buildah images | grep "${REPOSITORY_URI}"
        fi

  post_build:
    commands:
      - echo "=== POST-BUILD PHASE ==="
      - |
        set -e
        AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
        export AWS_ACCOUNT_ID
        ECR_REGISTRY="${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_DEFAULT_REGION}.amazonaws.com"
        export ECR_REGISTRY
        REPOSITORY_URI="${ECR_REGISTRY}/image-services"
        export REPOSITORY_URI
        
        if [ -n "${CODEBUILD_RESOLVED_SOURCE_VERSION}" ]; then
          COMMIT_HASH=$(echo "${CODEBUILD_RESOLVED_SOURCE_VERSION}" | cut -c 1-7)
        else
          COMMIT_HASH="latest"
        fi
        IMAGE_TAG="${COMMIT_HASH}"
        export IMAGE_TAG
        
        echo "Pushing images to ECR..."
      - |
        set -e
        echo "Pushing server tag..."
        buildah push "${REPOSITORY_URI}:server"
      - |
        set -e
        echo "Pushing latest tag..."
        buildah push "${REPOSITORY_URI}:latest"
      - |
        set -e
        echo "Pushing commit hash tag: ${IMAGE_TAG}"
        buildah push "${REPOSITORY_URI}:${IMAGE_TAG}"
      - echo "=== DEPLOYMENT PHASE ==="
      - |
        set -e
        AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
        export AWS_ACCOUNT_ID
        ECR_REGISTRY="${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_DEFAULT_REGION}.amazonaws.com"
        REPOSITORY_URI="${ECR_REGISTRY}/image-services"
        
        echo "Deploying to EC2 instance 'server'..."
        INSTANCE_ID=$(aws ec2 describe-instances \
          --filters "Name=tag:Name,Values=server" "Name=instance-state-name,Values=running" \
          --region "${AWS_DEFAULT_REGION}" \
          --query 'Reservations[0].Instances[0].InstanceId' \
          --output text 2>/dev/null || echo "")
        
        if [ -n "${INSTANCE_ID}" ] && [ "${INSTANCE_ID}" != "None" ]; then
          echo "Found running instance: ${INSTANCE_ID}"
          
          # Deploy using the update script on the instance
          echo "Triggering update script via SSM..."
          COMMAND_ID=$(aws ssm send-command \
            --instance-ids "${INSTANCE_ID}" \
            --document-name "AWS-RunShellScript" \
            --parameters "commands=[\"/opt/update-container.sh ${REPOSITORY_URI} server\"]" \
            --region "${AWS_DEFAULT_REGION}" \
            --query 'Command.CommandId' --output text)
            
          echo "SSM Command ID: ${COMMAND_ID}"
          
          # Wait for execution (simple wait loop)
          echo "Waiting for deployment to complete..."
          sleep 15
          
          STATUS=$(aws ssm get-command-invocation \
            --command-id "${COMMAND_ID}" \
            --instance-id "${INSTANCE_ID}" \
            --region "${AWS_DEFAULT_REGION}" \
            --query 'Status' --output text)
            
          echo "Deployment Status: ${STATUS}"
          
          if [ "${STATUS}" != "Success" ]; then
             # Fetch details if not success immediately visible (or pending)
             aws ssm get-command-invocation \
              --command-id "${COMMAND_ID}" \
              --instance-id "${INSTANCE_ID}" \
              --region "${AWS_DEFAULT_REGION}" \
              --query 'StandardErrorContent' --output text
          else
             aws ssm get-command-invocation \
              --command-id "${COMMAND_ID}" \
              --instance-id "${INSTANCE_ID}" \
              --region "${AWS_DEFAULT_REGION}" \
              --query 'StandardOutputContent' --output text
          fi
          
        else
          echo "WARNING: No running 'server' instance found. Skipping deployment."
        fi

